; Proyecto: Multiplicacion de matrices en 8086
; Integrantes: Humberto Villacis, Diego Hernandez, Pedro Sabatino, Ismael Quintero
; Organizacion del Computador - 2026

.model small
.stack 100h

.data
SUMLO dw 0  ; guarda la parte pequena de la suma acumulada
SUMHI dw 0  ; guarda la parte alta de la suma acumulada

N dw 3                      ; tamano de la matriz (entre 3 y 8)

; Matriz A (8x8, rellena con ceros si sobra)

A:    dw 1,  2,  5,  8,  0, 0, 0, 0,
      dw 3,  1,  2, 11,  0, 0, 0, 0,
      dw 2,  4,  3,  9,  0, 0, 0, 0,
      dw 6,  5,  7,  8,  0, 0, 0, 0,
      dw 0,  0,  0,  0,  0, 0, 0, 0,
      dw 0,  0,  0,  0,  0, 0, 0, 0,
      dw 0,  0,  0,  0,  0, 0, 0, 0,
      dw 0,  0,  0,  0,  0, 0, 0, 0

; Matriz B (8x8)

B:    dw 1,  0,  3,  2,  0, 0, 0, 0,
      dw 4, 10,  5,  2,  0, 0, 0, 0,
      dw -1, 4,  2,  7,  0, 0, 0, 0,
      dw 9,  3,  1,  8,  0, 0, 0, 0,
      dw 0,  0,  0,  0,  0, 0, 0, 0,
      dw 0,  0,  0,  0,  0, 0, 0, 0,
      dw 0,  0,  0,  0,  0, 0, 0, 0,
      dw 0,  0,  0,  0,  0, 0, 0, 0



; Matriz resultado (8x8 inicializada en 0)
PROD dw 64 dup(0)

.code
main PROC
    mov ax, @data
    mov ds, ax
    
    ; validar N antes de todo              
    call verificarTamano     
              
    ; Llamar a la rutina de multiplicacion
    call multiplicarMatrices

    ; Imprimir por filas
    call imprimirFilas

    ; Pausa (esperar tecla)
    mov ah, 1
    int 21h

    ; Imprimir por columnas
    call imprimirColumnas

    ; Terminar programa
    mov ax, 4C00h
    int 21h
main ENDP 

; Verfica si el tamano puesto es correcto
verificarTamano PROC
    ; Cargar N en AX
    mov ax, N

    ; ¿AX < 3?
    cmp ax, 3
    jl  vt_fail

    ; ¿AX > 8?
    cmp ax, 8
    jg  vt_fail

    ; OK ? continuar
    ret

vt_fail:
    ; Terminar programa directamente
    mov ax, 4C00h
    int 21h
verificarTamano ENDP


; -------------------------------
; Rutina de multiplicacion
; -------------------------------
; PROD[i][j] = sum_{k=0..N-1} A[i][k] * B[k][j]
; i, j, k recorren solo 0..N-1, pero las matrices estan almacenadas 8x8.
; Desplazamiento en palabras: i*8 + j (o k).
; Desplazamiento en bytes: (i*8 + j) * 2.

multiplicarMatrices PROC
    ; DI = i, SI = j, CX = k
    xor di, di              ; i = 0
for_i:
    cmp di, N
    jge end_mult

    xor si, si              ; j = 0
for_j:
    cmp si, N
    jge next_i

    ; sum = 0 (32 bits en SUMHI:SUMLO)
    mov SUMLO, 0
    mov SUMHI, 0

    xor cx, cx              ; k = 0
for_k:
    cmp cx, N
    jge store_prod

    ; ---------------------------
    ; Cargar A[i][k]
    ; bx = (i*8 + k) * 2
    mov bx, di              ; bx = i
    shl bx, 3               ; i*8
    add bx, cx              ; i*8 + k
    shl bx, 1               ; *2 -> bytes
    mov ax, [A + bx]        ; AX = A[i][k]

    ; ---------------------------
    ; Cargar B[k][j]
    ; bx = (k*8 + j) * 2
    mov bx, cx              ; bx = k
    shl bx, 3               ; k*8
    add bx, si              ; k*8 + j
    shl bx, 1               ; *2 -> bytes
    mov bp, [B + bx]        ; BP = B[k][j]

    ; ---------------------------
    ; Producto y acumulacion (signed)
    imul bp                 ; DX:AX = AX * BP (signed 16x16 -> 32 bits)

    ; sum += DX:AX
    ; SUMLO += AX, SUMHI += DX + carry
    push ax
    mov ax, SUMLO
    pop bx                  ; BX = producto low
    add ax, bx
    mov SUMLO, ax
    mov ax, SUMHI
    adc ax, dx
    mov SUMHI, ax

    ; siguiente k
    inc cx
    jmp for_k

store_prod:
    ; Guardar solo la parte baja en PROD[i][j]
    ; bx = (i*8 + j) * 2
    mov bx, di
    shl bx, 3               ; i*8
    add bx, si              ; i*8 + j
    shl bx, 1               ; *2 -> bytes

    mov ax, SUMLO
    mov [PROD + bx], ax

    ; siguiente j
    inc si
    jmp for_j

next_i:
    inc di
    jmp for_i

end_mult:
    ret
multiplicarMatrices ENDP

; -------------------------------
; Rutina para imprimir numeros

imprimirNumero PROC
    ; Convierte AX a decimal y lo imprime
    ; Usa pila para guardar digitos
    push ax
    cmp ax, 0
    jge skip_sign
    ; imprimir signo negativo
    mov dl, '-'
    mov ah, 2
    int 21h
    neg ax
skip_sign:
    mov cx, 0          ; contador de digitos
convert_loop:
    mov dx, 0
    mov bx, 10
    div bx             ; AX / 10, cociente en AX, residuo en DX
    push dx            ; guardar residuo
    inc cx
    cmp ax, 0
    jne convert_loop

print_loop:
    pop dx
    add dl, '0'
    mov ah, 2
    int 21h
    loop print_loop

    pop ax
    ret
imprimirNumero ENDP

; -------------------------------
; Rutina imprimir por filas
imprimirFilas PROC
    xor di, di              ; i = 0
fila_loop1:
    cmp di, N
    jge end_filas

    xor si, si              ; j = 0
col_loop2:
    cmp si, N
    jge next_fila

    ; offset = (i*8 + j)*2
    mov bx, di
    shl bx, 3               ; i*8
    add bx, si              ; i*8 + j
    shl bx, 1               ; *2 -> bytes
    mov ax, [PROD + bx]     ; AX = PROD[i][j]

    call imprimirNumero        ; imprimir numero

    ; imprimir espacio
    mov dl, ' '
    mov ah, 2
    int 21h

    inc si
    jmp col_loop2

next_fila:
    ; salto de linea
    mov dl, 0Dh
    mov ah, 2
    int 21h
    mov dl, 0Ah
    mov ah, 2
    int 21h

    inc di
    jmp fila_loop1

end_filas:
; salto de linea final
    mov dl, 0Dh
    mov ah, 2
    int 21h
    mov dl, 0Ah
    mov ah, 2
    int 21h

    ret
imprimirFilas ENDP

; -------------------------------
; Rutina imprimir por columnas
imprimirColumnas PROC
    xor si, si              ; j = 0 (columna)
col_loop3:
    cmp si, N
    jge end_cols

    xor di, di              ; i = 0 (fila)
fila_loop4:
    cmp di, N
    jge next_col

    ; offset = (i*8 + j)*2
    mov bx, di
    shl bx, 3               ; i*8
    add bx, si              ; i*8 + j
    shl bx, 1               ; *2 -> bytes
    mov ax, [PROD + bx]     ; AX = PROD[i][j]

    call imprimirNumero        ; imprimir numero

    ; imprimir espacio
    mov dl, ' '
    mov ah, 2
    int 21h

    inc di
    jmp fila_loop4

next_col:
    ; salto de linea al terminar una columna
    mov dl, 0Dh
    mov ah, 2
    int 21h
    mov dl, 0Ah
    mov ah, 2
    int 21h

    inc si
    jmp col_loop3

end_cols:
    ; pausa al final de impresion por columnas
    mov ah, 1
    int 21h

    ret
imprimirColumnas ENDP

END main